var documenterSearchIndex = {"docs":
[{"location":"report/#Method","page":"Report","title":"Method","text":"","category":"section"},{"location":"report/","page":"Report","title":"Report","text":"We use integers A=0 G=1 C=2 T=3 to represent each possible sequence, N_1N_2ldots N_k, of length k as an integer n=sum_1^k int(N_i)^k+1-i ranging from 0 to 4^k-1. A state in the Markov model is defined as an oligonucleotide of length k, and each state connects to 4 other states ((k-1)textmer+AGCT). The previous state shares k-1 bases with the next state. Therefore, there are 4^k+1 transitions in total. A genomic sequence under the k th-order Markov model can be viewed as a sequence of state-transitions. The transition probabilities can be calculated for each genome in the training data set according to its Markov model as following: $ kMM{i, mn}=P{i}\\left(O{m}\\rightarrow O{n}\\right)=\\frac{F{i}\\left(O{m}\\rightarrow O{n}\\right)}{F{i}\\left(O{m}\\right)}=\\sum{b \\in {\\text{A,G,C,T}}}\\frac{F{i}\\left(O{m}\\rightarrow O{n}\\right)}{F{i}\\left(O{m}\\rightarrow Ob\\right)} $","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"where O_m and O_n are oligonucleotides of length k. If O_n is ended with base b, we can also denote it as O_b. P_ileft(O_mrightarrow O_nright) represents the transition probability from O_m to O_n, F_ileft(O_mrightarrow O_nright) represents observed count of transitions from O_m to O_n in a genomic sequence i and F(O_m) is the observed count of O_m. Since F_ileft(O_mright) = sum_b in textAGCTF_ileft(O_mrightarrow O_bright), we can get the result using only the counts of (k+1)mers and there's no need for us to recount k mers. A 4^k+1 dimension vector is created to represent each genome.  Because we have to evaluate the transformation from k mer to the next base, a sequence of k+1 length is needed to be counted and recorded. We have to initialize a count vector with the length of 4^k+1. In practice, the minus logarithm value of each transition probability is saved.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"We read the sequence and count the transition states along the way, using sliding windows to improve the efficiency. A short sequence of length l can be considered as l-k transitions and a score S_i , which represents the distance between the short sequence and a genome i, can be computed as following: $ \\begin{align} S{i} &=-\\sum{j=0}^{l-k-1} \\ln \\left(P{i}\\left(O{j} \\rightarrow O{j+1}\\right)\\right)\\\n&=-\\sum{mn\\in (k+1)mer}fi(Om\\rightarrow On)\\ln(P{i}(O{m}\\rightarrow O{n}))\\\n&=-\\sum{mn\\in (k+1)mer}fi(Om\\rightarrow On)\\ln(\\sum{b \\in {\\text{A,G,C,T}}}\\frac{F{i}\\left(O{m}\\rightarrow O{n}\\right)}{F{i}\\left(O{m}\\rightarrow Ob\\right)}) \\end{align} $ where Oj$ and O_j+1 are two oligonucleotides of length k, and mn is O_m and O_n combined with the length of k+1, and P_i(O_j rightarrow O_j+1) is the transition probability from O_j to O_j+1 observed in the i-th genome. F_ileft(O_mrightarrow O_nright) represents observed count of transitions from O_m to O_n in a genomic sequence i and f_ileft(O_mrightarrow O_nright) is that in a query sequence. When the transition from O_j to O_j+1 does not exist in the i-th genome, the logarithm value of the transition probability will be set to a constant (default is 10). For each sequence, a genome in the database with the minimum score is selected as the source genome. At the end, each sequence will be annotated with the taxonomy information of its source genome. S_i can be calculated by the group of 4^k+1 categories of transition state, which enables that the counts of transition states in query sequence (denoted by a vector of 4^k+1 length for each query sequence and a matrix A of z times 4^k+1 scale for all z queries) and transition probabilities in the genome database (denoted by a vector of 4^k+1 length for each genome database and a matrix B of 2w times 4^k+1 scale for all w databases, considering the reversed sequences) can be calculated respectively. The score can be calculated by A*B^T and a scoring matix with a scale of ztimes 2w will return. Choose the best score in 2w scores of each query sequences, and the corresponding database can be the best-hit result.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"<img src=\"https://raw.githubusercontent.com/AquaIndigo/KMarkovGenSeq.jl/master/docs/src/assets/image-20210517103144335.png\" alt=\"image-20210517103144335\" style=\"zoom:50%;\" />","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"The algorithm complexity is determined by the number of genomes in the database and the order of Markov Models. It can be defined as follows:  $ T(k,N')\\sim O(N'\\times 4^k) $ where k represents the length of oligonucleotides and N stands for the number of genomes.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"In practice, the score S_i in equation is calculated by matrix multiplication. First, the transitions generated from each genome in the reference database are converted into a 4^k+1 diemension vector. Then, a matrix can be created from all vectors generated from genomes in the reference database. These can be prebuilt. For each short metagenomic sequence, the transitions generated from it are converted into a 4^k+1 dimension vector as well. Then, the scores are computed by matrix multiplication, which is done by calling the SGEMM() function of CUBLAS library. At the end, the best score is picked and the associated genome is selected as its source genome. These are done by GPUs and the taxonomy information about the source genomes is printed out by CPUs.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"In our project, we use numeric vector rather than string to record the sequences and bitwise operation rather than hash table to record the k th-order Markov model, so the efficiency can be improved. Also, matrix multiplication can be operated in GPUs thus our algorithm is capable even in extremely high dimensional cases.","category":"page"},{"location":"report/#Improvement","page":"Report","title":"Improvement","text":"","category":"section"},{"location":"report/","page":"Report","title":"Report","text":"The most time-consuming procedure of our project is counting the frequency of transition state, whereas matrix multiplication doesn't take long in comparison. Thus, matrix multiplication in GPU doesn't make it in speeding up in the scenario of this scale since transferring data (IO procedure of video memory and RAM) takes time, however, when in high dimensional cases, GPU computation makes sense.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Though using hash table to record the frequencies of all the sub-strings with length k+1 is the most straightforward way, considering the inefficiency and inconvenience in following operation, we used dynamic programming with sliding windows to count the transition states with the help of array, rather than hash table. Here, we call the sub-strings with length k+1 as k-sstr.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"In order to map the sub-strings to the indices of the array, we treat the sub-strings as quadratic numbers, since there are four cases for each bit of a k-sstr: A, G, C and T. And we can assign 0 to A, 1 to G, 2 to C and 3 to T. Therefore, all the k-sstr can be one-by-one-mapped to an integer from 0 to 4^k+1-1. And for example, when k=3, AAAA can be mapped to (0000)_4=0,  TTTT can be mapped to (3333)_4=255，while CGAT mapped to (2301)_4=2times4^3+3times4^2+0times4^1+1times4^0=177. And we can mapped any k-sstr to an integer index of an array.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Given a sequence with length l, if using the most naive algorithm to iterate through each k-sstr in the sequence and then compute the integer n=sum_1^k int(N_i)^k+1-i(N_iA=0 G=1 C=2 T=3) corresponding to this k-sstr, adding one to the number of subscript digits n in the counting array. It is easy to show that such a computation requires a complexity of mathcal O(k(l-k)). To speed up the counting operation, we adopt the idea of dynamic programming to see the overhead of mapping: Considering the simple fact if there is a sequence AGCTTCG, when we want to count the 3-sstr of it, at the beginning, we should count the integer n_1 corresponding to ss1=AGCT, and for the next 3-sstr ss2=GCTT corresponding to the integer n_2, we can give the following equation:  $ 4n1 \\bmod (3333)4 = n_2 - n(T), n(T) = 3 $ Thus, we can use the integer of the previous 3-sstr to compute the current 3-sstr value, and this computation requires only mathcal O(1) overhead, so counting k-sstr in a sequence of length N requires only mathcal O(N) time complexity.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Since we are dealing with a 4-decimal number and 4 is an integer power of 2, we can take a two-digit shift to the right instead of multiplying by 4 and use the with operation instead of the remainder operation, thus having the following implementation for this algorithm: ","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"function count_freq!(cnt::AbstractVector, seq::AbstractVector{UInt8}, len)\n    mask = typemax(UInt) >> (64 - 2 * len) # 2 * len bits of 1\n    len += 1\n    idx = UInt(0)\n    for i in 1:len-1 # calculate the prefix\n        idx += seq[i]\n        idx = idx << 2\n    end\n    \n    for num in seq[len:end]\n        idx += num\n        cnt[idx] += 1\n        idx = idx & mask\n        idx = idx << 2\n    end\nend","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Here we note that the time complexity does not increase with increasing k, but the running time of the actual program increases significantly with k. This is because, on the one hand, we need an array of length 4^k+1, and the operations of creating and initializing this array grow significantly as k increases; on the other hand, as k increases its corresponding integer range becomes larger, the gap between two adjacent integers corresponding to k-sstr increases, so the localization principle of memory access is broken, and thus the increase of k degrades the performance of the actual program.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Moreover, multi-threaded parallelism and synchronization in counting the transition states of a sequence also help, since the frequencies of each sequence counts are independent, so different tasks can be assigned to different processors to take full advantage of multi-core processors.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"In fact, it's questionable whether matrix multiplication can help in improving the time and space efficiency since the matrix of so short query sequence can be sparse. We considered using sparse matrices in order to speed up the computation of matrix multiplication and reduce the memory overhead. However, matrix multiplication only takes about 20% of the time, so while it does speed up in this part, the sparse matrix itself is not very accessible and lowers the efficiency.","category":"page"},{"location":"report/#Result","page":"Report","title":"Result","text":"","category":"section"},{"location":"report/","page":"Report","title":"Report","text":"## ten complete genome\n$ cat /home/faculty/ccwei/courses/2021/pab/proj1/seq_id.map | awk '!a[$2]++'\n0       Frankia symbiont of Datisca glomerata chromosome, complete genome\n1975    Hydrogenobaculum sp. Y04AAS1 chromosome, complete genome\n3985    Candidatus Midichloria mitochondrii IricVA chromosome, complete genome\n5908    Corynebacterium variabile DSM 44702 chromosome, complete genome\n7943    Psychromonas ingrahamii 37 chromosome, complete genome\n10002   Roseiflexus castenholzii DSM 13941 chromosome, complete genome\n12024   Alteromonas macleodii str. 'Deep ecotype' chromosome, complete genome\n14040   Denitrovibrio acetiphilus DSM 12809 chromosome, complete genome\n16045   Sphingomonas wittichii RW1 chromosome, complete genome\n18003   Baumannia cicadellinicola str. Hc (Homalodisca coagulata), complete genome\n\n## total number of short sequences\n$ grep '>' /home/faculty/ccwei/courses/2021/pab/proj1/reads.fa | wc -l\n1876","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"the total number of short sequences in the file reads.fa: 1876\nthe number of groups with at least j short sequences assigned, where j = 1, 5, 10 or 50. You can describe the results in a table similar to the one below. ","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Minimum number of short sequences in a group Number of groups\n1 10\n5 10\n10 10\n50 8","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"for those groups with at least 10 short sequences assigned, list the total numbers of short sequences assigned to those groups. Then you can draw a pie chart to show the relative frequency of each group. ","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Baumannia cicadellinicola str. Hc (Homalodisca coagulata), complete genome contains 298 query sequences\nPsychromonas ingrahamii 37 chromosome, complete genome contains 22 query sequences\nSphingomonas wittichii RW1 chromosome, complete genome contains 81 query sequences\nRoseiflexus castenholzii DSM 13941 chromosome, complete genome contains 375 query sequences\nHydrogenobaculum sp. Y04AAS1 chromosome, complete genome contains  104 query sequences\nAlteromonas macleodii str. 'Deep ecotype' chromosome, complete genome contains  279 query sequences\nDenitrovibrio acetiphilus DSM 12809 chromosome, complete genome contains 111 query sequences\nFrankia symbiont of Datisca glomerata chromosome, complete genome contains 23 query sequences\nCandidatus Midichloria mitochondrii IricVA chromosome, complete genome contains 348 query sequences\nCorynebacterium variabile DSM 44702 chromosome, complete genome contains 235 query sequences\nRoseiflexus 375\nCandidatus 348\nBaumannia 289\nAlteromonas 279\nCorynebacterium 235\nDenitrovibrio 111\nHydrogenobaculum 104\nSphingomonas 81\nFrankia 23\nPsychromonas 22\n<img src=\"https://raw.githubusercontent.com/AquaIndigo/KMarkovGenSeq.jl/master/docs/src/assets/image-20210524202132318.png\" alt=\"image-20210524202132318\" style=\"zoom:67%;\" />","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"For k=3-9, which k value gives the best classification result? Please give your own criteria for “good” result, and explain why this k value gives the best result. ","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"k accuracy\n3 0.60725\n4 0.63815\n5 0.65865\n6 0.68475\n7 0.7535\n8 0.8921\n9 0.9837","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Bonus: ","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"If you report how you use GPUs to do metagenomic sequence classification, and give the speedup compared to your CPU version, you will get a bonus of 5 points. ","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Using CPU\n\n0.151729 seconds (226.68 k allocations: 76.954 MiB)\n0.192870 seconds (230.42 k allocations: 77.655 MiB)\n0.311679 seconds (245.79 k allocations: 80.482 MiB)\n0.553789 seconds (307.25 k allocations: 91.793 MiB, 4.00% gc time)\n1.901767 seconds (553.01 k allocations: 137.254 MiB)\n5.736246 seconds (1.54 M allocations: 323.395 MiB, 0.32% gc time)\n27.172187 seconds (5.47 M allocations: 1.076 GiB, 0.39% gc time)\n\nUsing GPU\n\n0.186823 seconds (268.18 k allocations: 77.272 MiB)\n0.202832 seconds (315.47 k allocations: 78.642 MiB)\n0.368757 seconds (513.61 k allocations: 84.308 MiB, 4.24% gc time)\n0.814391 seconds (612.34 k allocations: 96.138 MiB)\n2.781158 seconds (1.32 M allocations: 148.650 MiB, 0.63% gc time)\n10.318713 seconds (3.99 M allocations: 360.579 MiB, 0.38% gc time)\n38.076606 seconds (19.35 M allocations: 1.283 GiB, 0.22% gc time)","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Thus, matrix multiplication in GPU doesn't make it in speeding up in the scenario of this scale since transferring data (IO procedure of Memory and RAM) takes time, however, when in high dimensional cases, GPU computation makes sense.","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Since the matrix of so short query sequence can be sparse, we considered using sparse matrices in order to speed up the computation of matrix multiplication and reduce the memory overhead. With sparse array:","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"  0.435236 seconds (105.41 k allocations: 67.727 MiB, 1.84% gc time)\n  1.590763 seconds (109.26 k allocations: 70.391 MiB)\n  8.156021 seconds (124.62 k allocations: 77.046 MiB, 0.05% gc time)\n 49.118710 seconds (186.06 k allocations: 89.670 MiB, 0.01% gc time)\n104.519134 seconds (431.82 k allocations: 128.380 MiB)\n141.280736 seconds (1.41 M allocations: 239.521 MiB, 0.02% gc time)\n148.108550 seconds (5.35 M allocations: 695.861 MiB, 0.07% gc time)","category":"page"},{"location":"report/","page":"Report","title":"Report","text":"Matrix multiplication only takes about 20% of the time, so while it does speed up in this part, the sparse matrix itself is not very accessible and lowers the efficiency.","category":"page"},{"location":"tests/#Benchmark","page":"Tests","title":"Benchmark","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"Using CPU\n\n0.151729 seconds (226.68 k allocations: 76.954 MiB)\n0.192870 seconds (230.42 k allocations: 77.655 MiB)\n0.311679 seconds (245.79 k allocations: 80.482 MiB)\n0.553789 seconds (307.25 k allocations: 91.793 MiB, 4.00% gc time)\n1.901767 seconds (553.01 k allocations: 137.254 MiB)\n5.736246 seconds (1.54 M allocations: 323.395 MiB, 0.32% gc time)\n27.172187 seconds (5.47 M allocations: 1.076 GiB, 0.39% gc time)\n\nUsing GPU\n\n0.186823 seconds (268.18 k allocations: 77.272 MiB)\n0.202832 seconds (315.47 k allocations: 78.642 MiB)\n0.368757 seconds (513.61 k allocations: 84.308 MiB, 4.24% gc time)\n0.814391 seconds (612.34 k allocations: 96.138 MiB)\n2.781158 seconds (1.32 M allocations: 148.650 MiB, 0.63% gc time)\n10.318713 seconds (3.99 M allocations: 360.579 MiB, 0.38% gc time)\n38.076606 seconds (19.35 M allocations: 1.283 GiB, 0.22% gc time)","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"With sparse array:","category":"page"},{"location":"tests/","page":"Tests","title":"Tests","text":"  0.435236 seconds (105.41 k allocations: 67.727 MiB, 1.84% gc time)\n  1.590763 seconds (109.26 k allocations: 70.391 MiB)\n  8.156021 seconds (124.62 k allocations: 77.046 MiB, 0.05% gc time)\n 49.118710 seconds (186.06 k allocations: 89.670 MiB, 0.01% gc time)\n104.519134 seconds (431.82 k allocations: 128.380 MiB)\n141.280736 seconds (1.41 M allocations: 239.521 MiB, 0.02% gc time)\n148.108550 seconds (5.35 M allocations: 695.861 MiB, 0.07% gc time)","category":"page"},{"location":"tests/#Questions","page":"Tests","title":"Questions","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"1. \n\nTotal query sequences: 1876\n\n4.\nNumber of groups containing at least 1 query sequences: 10\nNumber of groups containing at least 5 query sequences: 10\nNumber of groups containing at least 10 query sequences: 10\nNumber of groups containing at least 50 query sequences: 8\n\n5.\nBaumannia cicadellinicola str. Hc (Homalodisca coagulata), complete genomecontains      298     query sequences\nPsychromonas ingrahamii 37 chromosome, complete genomecontains  22      query sequences\nSphingomonas wittichii RW1 chromosome, complete genomecontains  81      query sequences\nRoseiflexus castenholzii DSM 13941 chromosome, complete genomecontains  375     query sequences\nHydrogenobaculum sp. Y04AAS1 chromosome, complete genomecontains        104     query sequences\nAlteromonas macleodii str. 'Deep ecotype' chromosome, complete genomecontains   279     query sequences\nDenitrovibrio acetiphilus DSM 12809 chromosome, complete genomecontains 111     query sequences\nFrankia symbiont of Datisca glomerata chromosome, complete genomecontains       23      query sequences\nCandidatus Midichloria mitochondrii IricVA chromosome, complete genomecontains  348     query sequences\nCorynebacterium variabile DSM 44702 chromosome, complete genomecontains 235     query sequences\n\ncounter = [298, 22, 81, 375, 104, 279, 111, 23, 348, 235]\n\n6.\n[ Info: k = 3, accuracy = 0.60725\n[ Info: k = 4, accuracy = 0.63815\n[ Info: k = 5, accuracy = 0.65865\n[ Info: k = 6, accuracy = 0.68475\n[ Info: k = 7, accuracy = 0.7535\n[ Info: k = 8, accuracy = 0.8921\n[ Info: k = 9, accuracy = 0.9837\nThe best k is 9 with accuracy 0.9837","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = KMarkovGenSeq","category":"page"},{"location":"#KMarkovGenSeq","page":"Home","title":"KMarkovGenSeq","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See our report in Report\nSee the performance and benchmark test in Tests","category":"page"},{"location":"#APIs","page":"Home","title":"APIs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [KMarkovGenSeq]","category":"page"},{"location":"#KMarkovGenSeq.cu_mat_mul!-Tuple{CUDA.CuArray{T, 2} where T, CUDA.CuArray{T, 2} where T, CUDA.CuArray{T, 2} where T}","page":"Home","title":"KMarkovGenSeq.cu_mat_mul!","text":"Wrapper of cuda lib functon cublasSgemm_v2 to do matrix multiplication.\n\nCalculate C = A' * B\n\ndims: m×n = (p×m)'p×n\n\n\n\n\n\n","category":"method"},{"location":"#KMarkovGenSeq.db_freq-Tuple{Any, Any}","page":"Home","title":"KMarkovGenSeq.db_freq","text":"Process the counts of each k-strr in several database  sequences. And the -log frequency will be given for the origin sequences and their reverse complementary sequences.\n\nThe first value to return is the descriptions of every database  sequences. The second is the -log frequencies.\n\nArgs:\n\ndbseqs: the forlder of the database sequences\nlen: do K-Markov algo with K = len\n\n\n\n\n\n","category":"method"},{"location":"#KMarkovGenSeq.query_freq","page":"Home","title":"KMarkovGenSeq.query_freq","text":"Perform K-Markov algorithm to predict where sequences come from.\n\nArgs:\n\nquery_seqs: the file containing the query sequences\ndbseqs: the forlder of the database sequences\nlen: do K-Markov algo with K = len\nout_file: the output file to give the predictions, default is nothing and\n\nno file will be given\n\nuse_gpu: whether to use gpu\n\n\n\n\n\n","category":"function"}]
}
